<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class OrderedMultiDictionary&lt;TKey, TValue&gt;
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class OrderedMultiDictionary&lt;TKey, TValue&gt;
   ">
    <meta name="generator" content="docfx 2.56.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2">
  
  
  <h1 id="Wintellect_PowerCollections_OrderedMultiDictionary_2" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2" class="text-break">Class OrderedMultiDictionary&lt;TKey, TValue&gt;
  </h1>
  <div class="markdown level0 summary"><p>The OrderedMultiDictionary class that associates values with a key. Unlike an OrderedDictionary,
each key can have multiple values associated with it. When indexing an OrderedMultidictionary, instead
of a single value associated with a key, you retrieve an enumeration of values.</p>
<p>All of the key are stored in sorted order. Also, the values associated with a given key 
are kept in sorted order as well.</p>
<p>When constructed, you can chose to allow the same value to be associated with a key multiple
times, or only one time. </p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html">CollectionBase</a>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, <span class="xref">System.Collections.Generic.ICollection</span>&lt;TValue&gt;&gt;&gt;</div>
    <div class="level2"><a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html">MultiDictionaryBase</a>&lt;TKey, TValue&gt;</div>
    <div class="level3"><span class="xref">OrderedMultiDictionary&lt;TKey, TValue&gt;</span></div>
  </div>
  <div classs="implements">
    <h5>Implements</h5>
    <div><span class="xref">System.Collections.ICollection</span></div>
    <div><span class="xref">System.Collections.Generic.IDictionary</span>&lt;TKey, <span class="xref">System.Collections.Generic.ICollection</span>&lt;TValue&gt;&gt;</div>
    <div><span class="xref">System.Collections.Generic.ICollection</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, <span class="xref">System.Collections.Generic.ICollection</span>&lt;TValue&gt;&gt;&gt;</div>
    <div><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, <span class="xref">System.Collections.Generic.ICollection</span>&lt;TValue&gt;&gt;&gt;</div>
    <div><span class="xref">System.Collections.IEnumerable</span></div>
    <div><span class="xref">System.ICloneable</span></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Clear">MultiDictionaryBase&lt;TKey, TValue&gt;.Clear()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Count">MultiDictionaryBase&lt;TKey, TValue&gt;.Count</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_EnumerateKeys">MultiDictionaryBase&lt;TKey, TValue&gt;.EnumerateKeys()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_TryEnumerateValuesForKey__0_System_Collections_Generic_IEnumerator__1___">MultiDictionaryBase&lt;TKey, TValue&gt;.TryEnumerateValuesForKey(TKey, IEnumerator&lt;TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Add_System_Collections_Generic_KeyValuePair__0_System_Collections_Generic_ICollection__1___">MultiDictionaryBase&lt;TKey, TValue&gt;.Add(KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_System_Collections_Generic_IDictionary_TKey_System_Collections_Generic_ICollection_TValue___Add__0_System_Collections_Generic_ICollection__1__">MultiDictionaryBase&lt;TKey, TValue&gt;.IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt;.Add(TKey, ICollection&lt;TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_AddMany__0_System_Collections_Generic_IEnumerable__1__">MultiDictionaryBase&lt;TKey, TValue&gt;.AddMany(TKey, IEnumerable&lt;TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Add__0__1_">MultiDictionaryBase&lt;TKey, TValue&gt;.Add(TKey, TValue)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Remove__0_">MultiDictionaryBase&lt;TKey, TValue&gt;.Remove(TKey)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Remove__0__1_">MultiDictionaryBase&lt;TKey, TValue&gt;.Remove(TKey, TValue)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Remove_System_Collections_Generic_KeyValuePair__0_System_Collections_Generic_ICollection__1___">MultiDictionaryBase&lt;TKey, TValue&gt;.Remove(KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_RemoveMany__0_System_Collections_Generic_IEnumerable__1__">MultiDictionaryBase&lt;TKey, TValue&gt;.RemoveMany(TKey, IEnumerable&lt;TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_RemoveMany_System_Collections_Generic_IEnumerable__0__">MultiDictionaryBase&lt;TKey, TValue&gt;.RemoveMany(IEnumerable&lt;TKey&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_System_Collections_Generic_IDictionary_TKey_System_Collections_Generic_ICollection_TValue___TryGetValue__0_System_Collections_Generic_ICollection__1___">MultiDictionaryBase&lt;TKey, TValue&gt;.IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt;.TryGetValue(TKey, ICollection&lt;TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_ContainsKey__0_">MultiDictionaryBase&lt;TKey, TValue&gt;.ContainsKey(TKey)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Contains__0__1_">MultiDictionaryBase&lt;TKey, TValue&gt;.Contains(TKey, TValue)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Contains_System_Collections_Generic_KeyValuePair__0_System_Collections_Generic_ICollection__1___">MultiDictionaryBase&lt;TKey, TValue&gt;.Contains(KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_EqualValues__1__1_">MultiDictionaryBase&lt;TKey, TValue&gt;.EqualValues(TValue, TValue)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_CountValues__0_">MultiDictionaryBase&lt;TKey, TValue&gt;.CountValues(TKey)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_CountAllValues">MultiDictionaryBase&lt;TKey, TValue&gt;.CountAllValues()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Keys">MultiDictionaryBase&lt;TKey, TValue&gt;.Keys</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Values">MultiDictionaryBase&lt;TKey, TValue&gt;.Values</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_System_Collections_Generic_IDictionary_TKey_System_Collections_Generic_ICollection_TValue___Values">MultiDictionaryBase&lt;TKey, TValue&gt;.IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt;.Values</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_KeyValuePairs">MultiDictionaryBase&lt;TKey, TValue&gt;.KeyValuePairs</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Item__0_">MultiDictionaryBase&lt;TKey, TValue&gt;.Item[TKey]</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_System_Collections_Generic_IDictionary_TKey_System_Collections_Generic_ICollection_TValue___Item__0_">MultiDictionaryBase&lt;TKey, TValue&gt;.IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt;.Item[TKey]</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_Replace__0__1_">MultiDictionaryBase&lt;TKey, TValue&gt;.Replace(TKey, TValue)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_ReplaceMany__0_System_Collections_Generic_IEnumerable__1__">MultiDictionaryBase&lt;TKey, TValue&gt;.ReplaceMany(TKey, IEnumerable&lt;TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_ToString">MultiDictionaryBase&lt;TKey, TValue&gt;.ToString()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.MultiDictionaryBase-2.html#Wintellect_PowerCollections_MultiDictionaryBase_2_GetEnumerator">MultiDictionaryBase&lt;TKey, TValue&gt;.GetEnumerator()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ToString">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.ToString()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Add__0_">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.Add(KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Clear">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.Clear()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Remove__0_">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.Remove(KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Contains__0_">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.Contains(KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_CopyTo__0___System_Int32_">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.CopyTo(KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;[], Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ToArray">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.ToArray()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Count">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.Count</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_Generic_ICollection_T__IsReadOnly">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.ICollection&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.IsReadOnly</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_AsReadOnly">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.AsReadOnly()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Exists_System_Predicate__0__">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.Exists(Predicate&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_TrueForAll_System_Predicate__0__">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.TrueForAll(Predicate&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_CountWhere_System_Predicate__0__">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.CountWhere(Predicate&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_FindAll_System_Predicate__0__">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.FindAll(Predicate&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_RemoveAll_System_Predicate__0__">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.RemoveAll(Predicate&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ForEach_System_Action__0__">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.ForEach(Action&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ConvertAll__1_System_Converter__0___0__">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.ConvertAll&lt;TOutput&gt;(Converter&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;, TOutput&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_GetEnumerator">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.GetEnumerator()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_CopyTo_System_Array_System_Int32_">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.ICollection.CopyTo(Array, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_IsSynchronized">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.ICollection.IsSynchronized</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_SyncRoot">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.ICollection.SyncRoot</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_IEnumerable_GetEnumerator">CollectionBase&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;.IEnumerable.GetEnumerator()</a>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.GetHashCode()</span>
    </div>
    <div>
      <span class="xref">System.Object.GetType()</span>
    </div>
    <div>
      <span class="xref">System.Object.MemberwiseClone()</span>
    </div>
    <div>
      <span class="xref">System.Object.ReferenceEquals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.ToString()</span>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="Wintellect.PowerCollections.html">Wintellect.PowerCollections</a></h6>
  <h6><strong>Assembly</strong>: CADability.dll</h6>
  <h5 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Serializable]
public class OrderedMultiDictionary&lt;TKey, TValue&gt; : MultiDictionaryBase&lt;TKey, TValue&gt;, ICollection, IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt;, ICollection&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;, IEnumerable&lt;KeyValuePair&lt;TKey, ICollection&lt;TValue&gt;&gt;&gt;, IEnumerable, ICloneable</code></pre>
  </div>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">TKey</span></td>
        <td><p>The type of the keys.</p>
</td>
      </tr>
      <tr>
        <td><span class="parametername">TValue</span></td>
        <td><p>The of values associated with the keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean)">OrderedMultiDictionary(Boolean)</h4>
  <div class="markdown level1 summary"><p>Create a new OrderedMultiDictionary. The default ordering of keys and values are used. If duplicate values
are allowed, multiple copies of the same value can be associated with the same key. For example, the key &quot;foo&quot;
could have &quot;a&quot;, &quot;a&quot;, and &quot;b&quot; associated with it. If duplicate values are not allowed, only one copies of a given value can
be associated with the same key, although different keys can have the same value. For example, the key &quot;foo&quot; could
have &quot;a&quot; and &quot;b&quot; associated with it, which key &quot;bar&quot; has values &quot;b&quot; and &quot;c&quot; associated with it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary(bool allowDuplicateValues)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">allowDuplicateValues</span></td>
        <td><p>Can the same value be associated with a key multiple times?</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_System_Boolean_System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0})">OrderedMultiDictionary(Boolean, IComparer&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Create a new OrderedMultiDictionary. If duplicate values
are allowed, multiple copies of the same value can be associated with the same key. For example, the key &quot;foo&quot;
could have &quot;a&quot;, &quot;a&quot;, and &quot;b&quot; associated with it. If duplicate values are not allowed, only one copies of a given value can
be associated with the same key, although different keys can have the same value. For example, the key &quot;foo&quot; could
have &quot;a&quot; and &quot;b&quot; associated with it, which key &quot;bar&quot; has values &quot;b&quot; and &quot;c&quot; associated with it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary(bool allowDuplicateValues, IComparer&lt;TKey&gt; keyComparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">allowDuplicateValues</span></td>
        <td><p>Can the same value be associated with a key multiple times?</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TKey&gt;</td>
        <td><span class="parametername">keyComparer</span></td>
        <td><p>An IComparer&lt;TKey&gt; instance that will be used to compare keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_System_Boolean_System_Collections_Generic_IComparer__0__System_Collections_Generic_IComparer__1__" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1})">OrderedMultiDictionary(Boolean, IComparer&lt;TKey&gt;, IComparer&lt;TValue&gt;)</h4>
  <div class="markdown level1 summary"><p>Create a new OrderedMultiDictionary. If duplicate values
are allowed, multiple copies of the same value can be associated with the same key. For example, the key &quot;foo&quot;
could have &quot;a&quot;, &quot;a&quot;, and &quot;b&quot; associated with it. If duplicate values are not allowed, only one copies of a given value can
be associated with the same key, although different keys can have the same value. For example, the key &quot;foo&quot; could
have &quot;a&quot; and &quot;b&quot; associated with it, which key &quot;bar&quot; has values &quot;b&quot; and &quot;c&quot; associated with it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary(bool allowDuplicateValues, IComparer&lt;TKey&gt; keyComparer, IComparer&lt;TValue&gt; valueComparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">allowDuplicateValues</span></td>
        <td><p>Can the same value be associated with a key multiple times?</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TKey&gt;</td>
        <td><span class="parametername">keyComparer</span></td>
        <td><p>An IComparer&lt;TKey&gt; instance that will be used to compare keys.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TValue&gt;</td>
        <td><span class="parametername">valueComparer</span></td>
        <td><p>An IComparer&lt;TValue&gt; instance that will be used to compare values.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_System_Boolean_System_Comparison__0__" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0})">OrderedMultiDictionary(Boolean, Comparison&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Create a new OrderedMultiDictionary. If duplicate values
are allowed, multiple copies of the same value can be associated with the same key. For example, the key &quot;foo&quot;
could have &quot;a&quot;, &quot;a&quot;, and &quot;b&quot; associated with it. If duplicate values are not allowed, only one copies of a given value can
be associated with the same key, although different keys can have the same value. For example, the key &quot;foo&quot; could
have &quot;a&quot; and &quot;b&quot; associated with it, which key &quot;bar&quot; has values &quot;b&quot; and &quot;c&quot; associated with it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary(bool allowDuplicateValues, Comparison&lt;TKey&gt; keyComparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">allowDuplicateValues</span></td>
        <td><p>Can the same value be associated with a key multiple times?</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;TKey&gt;</td>
        <td><span class="parametername">keyComparison</span></td>
        <td><p>A delegate to a method that will be used to compare keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2__ctor_System_Boolean_System_Comparison__0__System_Comparison__1__" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0},System.Comparison{`1})">OrderedMultiDictionary(Boolean, Comparison&lt;TKey&gt;, Comparison&lt;TValue&gt;)</h4>
  <div class="markdown level1 summary"><p>Create a new OrderedMultiDictionary. If duplicate values
are allowed, multiple copies of the same value can be associated with the same key. For example, the key &quot;foo&quot;
could have &quot;a&quot;, &quot;a&quot;, and &quot;b&quot; associated with it. If duplicate values are not allowed, only one copies of a given value can
be associated with the same key, although different keys can have the same value. For example, the key &quot;foo&quot; could
have &quot;a&quot; and &quot;b&quot; associated with it, which key &quot;bar&quot; has values &quot;b&quot; and &quot;c&quot; associated with it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary(bool allowDuplicateValues, Comparison&lt;TKey&gt; keyComparison, Comparison&lt;TValue&gt; valueComparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">allowDuplicateValues</span></td>
        <td><p>Can the same value be associated with a key multiple times?</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;TKey&gt;</td>
        <td><span class="parametername">keyComparison</span></td>
        <td><p>A delegate to a method that will be used to compare keys.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;TValue&gt;</td>
        <td><span class="parametername">valueComparison</span></td>
        <td><p>A delegate to a method that will be used to compare values.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Count_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Count*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Count" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Count">Count</h4>
  <div class="markdown level1 summary"><p>Gets the number of key-value pairs in the dictionary. Each value associated
with a given key is counted. If duplicate values are permitted, each duplicate
value is included in the count.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override sealed int Count { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of key-value pairs in the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.Count</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_KeyComparer_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.KeyComparer*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_KeyComparer" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.KeyComparer">KeyComparer</h4>
  <div class="markdown level1 summary"><p>Returns the IComparer&lt;T&gt; used to compare keys in this dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IComparer&lt;TKey&gt; KeyComparer { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TKey&gt;</td>
        <td><p>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
created using a comparison delegate, then a comparer equivalent to that delegate
is returned. Otherwise
the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_KeyValuePairs_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.KeyValuePairs*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_KeyValuePairs" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.KeyValuePairs">KeyValuePairs</h4>
  <div class="markdown level1 summary"><p>Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
values associated with it, then a key-value pair is present for each value associated
with the key.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override sealed ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; KeyValuePairs { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.ICollection</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.KeyValuePairs</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_ValueComparer_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.ValueComparer*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_ValueComparer" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.ValueComparer">ValueComparer</h4>
  <div class="markdown level1 summary"><p>Returns the IComparer&lt;T&gt; used to compare values in this dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IComparer&lt;TValue&gt; ValueComparer { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TValue&gt;</td>
        <td><p>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
created using a comparison delegate, then a comparer equivalent to that delegate
is returned. Otherwise
the default comparer for TValue (Comparer&lt;TValue&gt;.Default) is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Add_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Add*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Add__0__1_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Add(`0,`1)">Add(TKey, TValue)</h4>
  <div class="markdown level1 summary"><p>Adds a new value to be associated with a key. If duplicate values are permitted, this
method always adds a new key-value pair to the dictionary.</p>
<p>If duplicate values are not permitted, and <code data-dev-comment-type="paramref" class="paramref">key</code> already has a value
equal to <code data-dev-comment-type="paramref" class="paramref">value</code> associated with it, then that value is replaced with <code data-dev-comment-type="paramref" class="paramref">value</code>,
and the number of values associate with <code data-dev-comment-type="paramref" class="paramref">key</code> is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override sealed void Add(TKey key, TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to associate with.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>The value to associated with <code data-dev-comment-type="paramref" class="paramref">key</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.Add(TKey, TValue)</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Clear_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Clear*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Clear" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Clear">Clear()</h4>
  <div class="markdown level1 summary"><p>Removes all keys and values from the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override sealed void Clear()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.Clear()</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Clone_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Clone*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Clone" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Clone">Clone()</h4>
  <div class="markdown level1 summary"><p>Makes a shallow clone of this dictionary; i.e., if keys or values of the
dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary&lt;TKey, TValue&gt; Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedMultiDictionary-2.html">OrderedMultiDictionary</a>&lt;TKey, TValue&gt;</td>
        <td><p>The cloned dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_CloneContents_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.CloneContents*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_CloneContents" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.CloneContents">CloneContents()</h4>
  <div class="markdown level1 summary"><p>Makes a deep clone of this dictionary. A new dictionary is created with a clone of
each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
a value type, then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary&lt;TKey, TValue&gt; CloneContents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedMultiDictionary-2.html">OrderedMultiDictionary</a>&lt;TKey, TValue&gt;</td>
        <td><p>The cloned dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_CloneContents_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If TKey or TValue is a reference type, it must implement
    ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>TKey or TValue is a reference type that does not implement ICloneable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Contains_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Contains*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Contains__0__1_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Contains(`0,`1)">Contains(TKey, TValue)</h4>
  <div class="markdown level1 summary"><p>Checks to see if <code data-dev-comment-type="paramref" class="paramref">value</code> is associated with <code data-dev-comment-type="paramref" class="paramref">key</code>
in the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override sealed bool Contains(TKey key, TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to check.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>The value to check.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if <code data-dev-comment-type="paramref" class="paramref">value</code> is associated with <code data-dev-comment-type="paramref" class="paramref">key</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.Contains(TKey, TValue)</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_ContainsKey_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.ContainsKey*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_ContainsKey__0_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.ContainsKey(`0)">ContainsKey(TKey)</h4>
  <div class="markdown level1 summary"><p>Checks to see if the key is present in the dictionary and has
at least one value associated with it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override sealed bool ContainsKey(TKey key)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to check.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if <code data-dev-comment-type="paramref" class="paramref">key</code> is present and has at least
one value associated with it. Returns false otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.ContainsKey(TKey)</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_CountAllValues_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.CountAllValues*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_CountAllValues" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.CountAllValues">CountAllValues()</h4>
  <div class="markdown level1 summary"><p>Gets a total count of values in the collection.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected override sealed int CountAllValues()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The total number of values associated with all keys in the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.CountAllValues()</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_CountValues_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.CountValues*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_CountValues__0_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.CountValues(`0)">CountValues(TKey)</h4>
  <div class="markdown level1 summary"><p>Gets the number of values associated with a given key.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected override sealed int CountValues(TKey key)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to count values of.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of values associated with <code data-dev-comment-type="paramref" class="paramref">key</code>. If <code data-dev-comment-type="paramref" class="paramref">key</code>
is not present in the dictionary, zero is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.CountValues(TKey)</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_EnumerateKeys_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.EnumerateKeys*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_EnumerateKeys" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.EnumerateKeys">EnumerateKeys()</h4>
  <div class="markdown level1 summary"><p>Enumerate all of the keys in the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected override sealed IEnumerator&lt;TKey&gt; EnumerateKeys()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerator</span>&lt;TKey&gt;</td>
        <td><p>An IEnumerator&lt;TKey&gt; of all of the keys in the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.EnumerateKeys()</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_EqualValues_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.EqualValues*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_EqualValues__1__1_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.EqualValues(`1,`1)">EqualValues(TValue, TValue)</h4>
  <div class="markdown level1 summary"><p>Determine if two values are equal.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected override sealed bool EqualValues(TValue value1, TValue value2)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value1</span></td>
        <td><p>First value to compare.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value2</span></td>
        <td><p>Second value to compare.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the values are equal.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.EqualValues(TValue, TValue)</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Item_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Item*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Item__0_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Item(`0)">Item(TKey)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TValue Item(TKey key)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Range_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Range*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Range__0_System_Boolean__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">Range(TKey, Boolean, TKey, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a collection that can be used for enumerating some of the keys and values in the collection.
Only keys that are greater than <code data-dev-comment-type="paramref" class="paramref">from</code> and
less than <code data-dev-comment-type="paramref" class="paramref">to</code> are included. The keys are enumerated in sorted order.
Keys equal to the end points of the range can be included or excluded depending on the
<code data-dev-comment-type="paramref" class="paramref">fromInclusive</code> and <code data-dev-comment-type="paramref" class="paramref">toInclusive</code> parameters.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary&lt;TKey, TValue&gt;.View Range(TKey from, bool fromInclusive, TKey to, bool toInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">from</span></td>
        <td><p>The lower bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">fromInclusive</span></td>
        <td><p>If true, the lower bound is inclusive--keys equal to the lower bound will
be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
be included in the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">to</span></td>
        <td><p>The upper bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">toInclusive</span></td>
        <td><p>If true, the upper bound is inclusive--keys equal to the upper bound will
be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedMultiDictionary-2.View.html">OrderedMultiDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedMultiDictionary.View of key-value pairs in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Range__0_System_Boolean__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If <code data-dev-comment-type="paramref" class="paramref">from</code> is greater than or equal to <code data-dev-comment-type="paramref" class="paramref">to</code>, the returned collection is empty. </p>
<p>The sorted order of the keys is determined by the comparison instance or delegate used
 to create the dictionary.</p>
<p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.Range(from, true, to, false)) {
    // process pair
 }</code></pre>
<p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_RangeFrom_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.RangeFrom*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_RangeFrom__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.RangeFrom(`0,System.Boolean)">RangeFrom(TKey, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a collection that can be used for enumerating some of the keys and values in the collection.
Only keys that are greater than (and optionally, equal to) <code data-dev-comment-type="paramref" class="paramref">from</code> are included.
The keys are enumerated in sorted order. Keys equal to <code data-dev-comment-type="paramref" class="paramref">from</code> can be included
or excluded depending on the <code data-dev-comment-type="paramref" class="paramref">fromInclusive</code> parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary&lt;TKey, TValue&gt;.View RangeFrom(TKey from, bool fromInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">from</span></td>
        <td><p>The lower bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">fromInclusive</span></td>
        <td><p>If true, the lower bound is inclusive--keys equal to the lower bound will
be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedMultiDictionary-2.View.html">OrderedMultiDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedMultiDictionary.View of key-value pairs in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_RangeFrom__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The sorted order of the keys is determined by the comparison instance or delegate used
 to create the dictionary.</p>
<p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.RangeFrom(from, true)) {
    // process pair
 }</code></pre>
<p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_RangeTo_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.RangeTo*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_RangeTo__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.RangeTo(`0,System.Boolean)">RangeTo(TKey, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a collection that can be used for enumerating some of the keys and values in the collection.
Only items that are less than (and optionally, equal to) <code data-dev-comment-type="paramref" class="paramref">to</code> are included.
The items are enumerated in sorted order. Items equal to <code data-dev-comment-type="paramref" class="paramref">to</code> can be included
or excluded depending on the <code data-dev-comment-type="paramref" class="paramref">toInclusive</code> parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary&lt;TKey, TValue&gt;.View RangeTo(TKey to, bool toInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">to</span></td>
        <td><p>The upper bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">toInclusive</span></td>
        <td><p>If true, the upper bound is inclusive--keys equal to the upper bound will
be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedMultiDictionary-2.View.html">OrderedMultiDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedMultiDictionary.View of key-value pairs in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_RangeTo__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The sorted order of the keys is determined by the comparison instance or delegate used
 to create the dictionary.</p>
<p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.RangeFrom(from, false)) {
    // process pair
 }</code></pre>
<p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Remove_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Remove*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Remove__0_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Remove(`0)">Remove(TKey)</h4>
  <div class="markdown level1 summary"><p>Removes a key and all associated values from the dictionary. If the
key is not present in the dictionary, it is unchanged and false is returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override sealed bool Remove(TKey key)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to remove.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the key was present and was removed. Returns
false if the key was not present.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.Remove(TKey)</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Remove_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Remove*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Remove__0__1_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Remove(`0,`1)">Remove(TKey, TValue)</h4>
  <div class="markdown level1 summary"><p>Removes a given value from the values associated with a key. If the
last value is removed from a key, the key is removed also.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override sealed bool Remove(TKey key, TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>A key to remove a value from.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>The value to remove.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if <code data-dev-comment-type="paramref" class="paramref">value</code> was associated with <code data-dev-comment-type="paramref" class="paramref">key</code> (and was
therefore removed). False if <code data-dev-comment-type="paramref" class="paramref">value</code> was not associated with <code data-dev-comment-type="paramref" class="paramref">key</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.Remove(TKey, TValue)</span></div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Reversed_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Reversed*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Reversed" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.Reversed">Reversed()</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating the keys and values in the collection in
reversed order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedMultiDictionary&lt;TKey, TValue&gt;.View Reversed()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedMultiDictionary-2.View.html">OrderedMultiDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedDictionary.View of key-value pairs in reverse order.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_Reversed_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.Reversed()) {
    // process pair
 }</code></pre></p>
<p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_TryEnumerateValuesForKey_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.TryEnumerateValuesForKey*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_TryEnumerateValuesForKey__0_System_Collections_Generic_IEnumerator__1___" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">TryEnumerateValuesForKey(TKey, out IEnumerator&lt;TValue&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this dictionary contains a key equal to <code data-dev-comment-type="paramref" class="paramref">key</code>. If so, all the values
associated with that key are returned through the values parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">protected override sealed bool TryEnumerateValuesForKey(TKey key, out IEnumerator&lt;TValue&gt; values)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to search for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerator</span>&lt;TValue&gt;</td>
        <td><span class="parametername">values</span></td>
        <td><p>Returns all values associated with key, if true was returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the dictionary contains key. False if the dictionary does not contain key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.MultiDictionaryBase&lt;TKey, TValue&gt;.TryEnumerateValuesForKey(TKey, System.Collections.Generic.IEnumerator&lt;TValue&gt;)</span></div>
  <h3 id="eii">Explicit Interface Implementations
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedMultiDictionary_2_System_ICloneable_Clone_" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.System#ICloneable#Clone*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedMultiDictionary_2_System_ICloneable_Clone" data-uid="Wintellect.PowerCollections.OrderedMultiDictionary`2.System#ICloneable#Clone">ICloneable.Clone()</h4>
  <div class="markdown level1 summary"><p>Implements ICloneable.Clone. Makes a shallow clone of this dictionary; i.e., if keys or values are reference types, then they are not cloned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">object ICloneable.Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Object</span></td>
        <td><p>The cloned dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="implements">Implements</h3>
  <div>
      <span class="xref">System.Collections.ICollection</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.IDictionary&lt;TKey, TValue&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.ICollection&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.IEnumerable&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.IEnumerable</span>
  </div>
  <div>
      <span class="xref">System.ICloneable</span>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
